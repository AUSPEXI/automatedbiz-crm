import { supabase } from './supabase';
import { openai, isOpenAIConfigured, getMockAIResponse, handleAIError } from './openai';
import type { BlogPost, BlogCategory, BlogTag } from '../types/blog';

class BlogService {
  generateSlug(title: string): string {
    return title
      .toLowerCase()
      .replace(/[^a-z0-9]+/g, '-')
      .replace(/(^-|-$)/g, '');
  }

  async getPosts(page = 1, status?: string) {
    try {
      const { data: { session }, error: authError } = await supabase.auth.getSession();
      if (authError) throw authError;

      let query = supabase
        .from('blog_posts')
        .select(`
          *,
          category:blog_categories(*),
          tags:blog_post_tags(blog_tags(*))
        `)
        .order('created_at', { ascending: false });

      if (status) query = query.eq('status', status);
      const from = (page - 1) * 10;
      const to = from + 9;
      query = query.range(from, to);

      const { data, error } = await query;
      if (error) throw error;
      return data || [];
    } catch (error) {
      console.error('Error fetching posts:', error);
      return [];
    }
  }

  async getPostBySlug(slug: string) {
    try {
      const { data: { session }, error: authError } = await supabase.auth.getSession();
      if (authError) throw authError;

      const { data, error } = await supabase
        .from('blog_posts')
        .select(`
          *,
          category:blog_categories(*),
          tags:blog_post_tags(blog_tags(*))
        `)
        .eq('slug', slug)
        .single();

      if (error) throw error;
      return data;
    } catch (error) {
      console.error('Error fetching post:', error);
      throw error;
    }
  }

  async createPost(post: Partial<BlogPost>) {
    try {
      const { data: { session }, error: authError } = await supabase.auth.getSession();
      if (authError) throw authError;

      if (!session?.user?.id) throw new Error('No authenticated user found');

      if (!post.slug && post.title) {
        post.slug = this.generateSlug(post.title);
      }

      const { data, error } = await supabase
        .from('blog_posts')
        .insert([{ ...post, author_id: session.user.id }])
        .select()
        .single();

      if (error) throw error;
      return data;
    } catch (error) {
      console.error('Error creating post:', error);
      throw error;
    }
  }

  async generateContent(topic: string): Promise<BlogPost | null> {
    try {
      if (!topic.trim()) throw new Error('Topic is required');

      const { data: { session }, error: authError } = await supabase.auth.getSession();
      if (authError) throw authError;

      let content: string;
      let title = topic;

      if (isOpenAIConfigured()) {
        try {
          const completion = await openai.chat.completions.create({
            model: "gpt-4",
            messages: [
              { role: "system", content: "You are a professional blog writer with expertise in marketing and business." },
              { role: "user", content: `Write a detailed blog post about ${topic}. Include: Introduction, Main points, Analysis, Examples, Best practices, Conclusion. Make it SEO-optimized and engaging.` },
            ],
            temperature: 0.7,
            max_tokens: 2000,
          });
          content = completion.choices[0].message.content || '';
          if (!content) throw new Error('No content generated by AI');
        } catch (error) {
          console.warn('OpenAI error, falling back to mock:', handleAIError(error));
          const mockResponse = getMockAIResponse(topic);
          content = mockResponse.choices[0].message.content;
        }
      } else {
        const mockResponse = getMockAIResponse(topic);
        content = mockResponse.choices[0].message.content;
      }

      const postData = {
        title,
        content,
        excerpt: content.slice(0, 200) + '...',
        status: 'draft',
        ai_generated: true,
        author_id: session?.user?.id || 'mock-user-id',
        seo_title: title,
        seo_description: content.slice(0, 160),
        slug: this.generateSlug(title),
        publish_date: new Date().toISOString(),
      };

      const { data, error } = await supabase
        .from('blog_posts')
        .insert([postData])
        .select()
        .single();

      if (error) {
        console.error('Database error, returning mock:', error);
        return { id: `mock-${Date.now()}`, ...postData, created_at: new Date().toISOString(), updated_at: new Date().toISOString() } as BlogPost;
      }

      return data;
    } catch (error) {
      console.error('Error generating content:', error);
      throw error;
    }
  }

  async updatePost(id: string, updates: Partial<BlogPost>) {
    try {
      const { data: { session }, error: authError } = await supabase.auth.getSession();
      if (authError) throw authError;

      if (!session?.user?.id) throw new Error('No authenticated user found');

      if (updates.title && !updates.slug) {
        updates.slug = this.generateSlug(updates.title);
      }

      const { data, error } = await supabase
        .from('blog_posts')
        .update(updates)
        .eq('id', id)
        .select()
        .single();

      if (error) throw error;
      return data;
    } catch (error) {
      console.error('Error updating post:', error);
      throw error;
    }
  }

  async deletePost(id: string) {
    try {
      const { data: { session }, error: authError } = await supabase.auth.getSession();
      if (authError) throw authError;

      if (!session?.user?.id) throw new Error('No authenticated user found');

      const { error } = await supabase
        .from('blog_posts')
        .delete()
        .eq('id', id);

      if (error) throw error;
    } catch (error) {
      console.error('Error deleting post:', error);
      throw error;
    }
  }

  async getCategories(): Promise<BlogCategory[]> {
    try {
      const { data, error } = await supabase
        .from('blog_categories')
        .select('*')
        .order('name');

      if (error) throw error;
      return data || [];
    } catch (error) {
      console.error('Error fetching categories:', error);
      return [];
    }
  }

  async getTags(): Promise<BlogTag[]> {
    try {
      const { data, error } = await supabase
        .from('blog_tags')
        .select('*')
        .order('name');

      if (error) throw error;
      return data || [];
    } catch (error) {
      console.error('Error fetching tags:', error);
      return [];
    }
  }
}

export const blogService = new BlogService();